## 算法笔记
### 算法：「算法Algorithm」是在有限时间内解决特定问题的一组指令或者操作步骤。<br/>
算法有以下特性：<br/>
1、问题是明确的，包含清晰的输入和输出定义。<br/>
2、具有可行性，能够在有限步骤、时间和内存空间下完成。<br/>
3、各步骤都有确定的含义，相同的输入和运行条件下，输出始终相同。<br/>

### 数据结构：「数据结构 Data Structure」是计算机中组织和存储数据的方式。为了提高数据存储数据和操作性能，数据结构的设计目标包括：<br/>
1、空间占用尽可能减少，节省计算机内存。<br/>
2、数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。<br/>
3、提供简洁的数据表示和逻辑信息，以便似的算法高效运行。<br/>

### 数据结构与算法的关系：<br/>
「数据结构」与「算法」高度相关且精密结合，具体表现在：<br/>
1、数据结构是算法的基石。数据结构为算法提供了结构式储存的数据，以及用于操作数据的方法。<br/>
2、算法是数据结构发挥的舞台。数据结构本身仅存储数据信息，通过结合算法才能解决待定问题。<br/>
3、特定算法通常有对应最优的数据结构。算法通常可以基于不同的数据结构进行实现，但最终执行效率可能相差很大。<br/>

### 算法效率评估
1、时间效率，即算法运行速度的快慢。<br/>
     时间复杂度用于衡量算法运行时间随数据量增长的趋势  <br/>
2、空间效率，即算法占用内存空间的大小。<br/>
     空间复杂度用于衡量算法占用空间随数据量增长的趋势。<br/>
### 效率评估方法
1、实际测试 <br/>
2、理论估算 <br/>
## 数据结构分类
### 数据结构分类
数据结构可以从逻辑结构和物理结构两个维度进行分类。<br/>
#### 逻辑结构 线性与非线性
「逻辑结构」反映了数据元素之间的逻辑关系。<br/>
 线性数据结构：数组、链表、栈、队列、哈希表；<br/>
 非线性数据结构：树、图、堆、哈希表；<br/>
#### 物理结构：连续与离散
「物理结构」反映了数据在计算机内存中的存储方式。<br/>
 所有的数据结构都是基于数组、链表或者二者的组合实现的。<br/>
 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等。 <br/>
 基于链表可实现：栈、队列、哈希表、树、堆、图等。<br/>
基于数组实现的数据结构也被称为「静态数据结构」，这意味着此类数据结构在初始化后长度不可变。相对应地，基于链表实现的数据结构被称为「动态数据结构」，这类数据结构在初始化后，仍可以在程序运行过程中对其长度进行调整。<br/>
#### 数据类型与编码
计算机中的基本数据类型包括整数 byte, short, int, long 、浮点数 float, double 、字符 char 和布尔 boolean 。它们的取值范围取决于占用空间大小和表示方式。<br/>
原码、反码和补码是在计算机中编码数字的三种方法，它们之间是可以相互转换的。整数的原码的最高位是符号位，其余位是数字的值。<br/>
UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。UTF-16 和 UTF-32 是等长的编码方法。<br/>

#### 数组和链表
数组和链表是两种基本数据结构，分别代表数据在计算机内存中的连续空间存储和离散空间存储方法<br/>
数组支持随机访问、暂用内存较少；但是插入和删除元素效率低，且初始化后长度不可变<br/>
链表铜过更改指针实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多。常见的链表类型包括单向链表、循环链表、双向链表。
动态数组，又称为列表、是基于数组实现的一种数据结构。它保留了数组的优势、同时又可以灵活调整长度。列表的出现极大的提高了数组的易用性，但可能导致部分内存空间浪费。

|    | 数组 | 链表   |
|:--------:|:--------:| :-------------:|
| 存储方式|连续内存空间|离散内存空间 |
| 数据结构长度 | 长度不可变 |长度可变 |
| 内存使用率	| 占用内存少、缓存局部性好 |占用内存多 |
| 优势操作 | 随机访问 |插入、删除 |
| 访问元素 | O(1) |O(N)  |
| 添加元素 | O(N)  |O(1)  |
| 删除元素 | O(N)  |O(1)  |

#### 栈与队列
栈是一种遵循先入后原则的数据结构，可以通过数组或者链表来实现。
 <br/>
从时间效率角度看，栈的数组实现具有较高的平均效率，但是在扩容过程中，单次入栈操作的时间会降低至O(n)，相比之下，基于链表实现的栈具有更加稳定的效率表现。<br/>
从空间效率方面，栈的数组实现可能导致一定的空间浪费。但需要注意的是，链表节点所占用的内存比数组元素更加大 。<br/>
队列是一种遵循先入先出的数据结构，同样可以通过数组或者链表来实现。<br/>
从效率来看，和栈的相似。时间：数组实现具有更高的效率，链表具有更加稳定的效率；空间：数组实现可能导致一定的空间浪费，但是链表节点所占用的内存比数组元素更加大。<br/>

### 哈希表
输入 key ，哈希表能够在  时间内查询到 value ，效率非常高。<br/>
常见的哈希表操作包括查询、添加键值对、删除键值对和遍历哈希表等。<br/>
哈希函数将 key 映射为数组索引，从而访问对应桶并获取 value 。<br/>
两个不同的 key 可能在经过哈希函数后得到相同的数组索引，导致查询结果出错，这种现象被称为哈希冲突。<br/>
哈希表容量越大，哈希冲突的概率就越低。因此可以通过扩容哈希表来缓解哈希冲突。与数组扩容类似，哈希表扩容操作的开销很大。<br/>
负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。<br/>
链式地址通过将单个元素转化为链表，将所有冲突元素存储在同一个链表中。然而，链表过长会降低查询效率，可以进一步将链表转换为红黑树来提高效率。<br/>
开放寻址通过多次探测来处理哈希冲突。线性探测使用固定步长，缺点是不能删除元素，且容易产生聚集。多次哈希使用多个哈希函数进行探测，相较线性探测更不易产生聚集，但多个哈希函数增加了计算量。<br/>
不同编程语言采取了不同的哈希表实现。例如，Java 的 HashMap 使用链式地址，而 Python 的 Dict 采用开放寻址。<br/>
在哈希表中，我们希望哈希算法具有确定性、高效率和均匀分布的特点。在密码学中，哈希算法还应该具备抗碰撞性和雪崩效应。<br/>
哈希算法通常采用大质数作为模数，以最大化地保证哈希值的均匀分布，减少哈希冲突。<br/>
常见的哈希算法包括 MD5, SHA-1, SHA-2, SHA3 等。MD5 常用于校验文件完整性，SHA-2 常用于安全应用与协议。<br/>
编程语言通常会为数据类型提供内置哈希算法，用于计算哈希表中的桶索引。通常情况下，只有不可变对象是可哈希的。<br/>

### 树
二叉树是一种非线性数据结构，提现了”一分为二“的分治逻辑。每个二叉树节点包含了一个值以及两个指针，分别指向其左子节点和右子节点。<br/>
对于二叉树中的某个节点，其左（右）子节点及其以下形成的树被称为该节点的左（右）子树。<br/>
二叉树的相关术语包括根节点、叶节点、层、度、边、高度、深度。<br/>
二叉树的初始化、节点插入和节点删除操作与链表操作方式类似。<br/>
常见的二叉树类型有完美二叉树、完全二叉树、完满二叉树和平衡二叉树。完美二叉树是最理想的状态，而链表是退化后的最差状态。<br/>
二叉树可以用数组表示，方法是将节点值和空位按层序遍历顺序排列，并根据父节点与子节点之间的索引映射关系来实现指针。<br/>
二叉树的层序遍历是一种广度优先搜索方法，它体现了”一圈一圈向外“的分层遍历方式，通常通过队列来实现。<br/>
前序、中序、后序遍历皆属于深度优先搜索，它们体现了”走到尽头、再回头继续“的回溯遍历方式，通常使用递归来实现。<br/>
二叉搜索树是一种高效的元素查找数据结构，其查找、插入和删除操作的时间复杂度均为O(log n)。当二叉搜索树退出为链时，各项时间复杂度会劣化至O(n)。<br/>
AVL树，也称为平衡二叉搜索树，它通过旋转操作，确保在不断插入和删除节点后，树仍然保持平衡。<br/>
AVL树的旋转操作包括右旋、左旋、先右旋再左旋、先左旋再右旋。在插入或者删除节点后，AVL树会从底层向顶层旋转操作，使树重新恢复平衡。<br/>

### 堆
堆是一棵完全二叉树，根据成立条件可分为大顶堆和小顶堆。大（小）顶堆的堆顶元素是最大（小）的。<br/>
优先队列的定义是具有出队优先级的队列，通常使用堆来实现。<br/>
堆的常用操作及其对应的时间复杂度包括：元素入堆O(log n)、堆顶元素出堆O(log n)和访问堆顶元素O(1)  等。<br/>
完全二叉树非常适合用数组表示，因此我们通常使用数组来存储堆。<br/>
堆化操作用于维护堆的性质，在入堆和出堆操作中都会用到。<br/>
输入n个元素并建堆的时间复杂度可以优化至O(n)，非常高效。<br/>
Top-K是一个经典算法问题，可以使用堆数据结构高效解决，时间复杂度为O(nlognk) 。<br/>

